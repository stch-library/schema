<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>stch.schema documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Schema 0.3.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="stch.schema.html"><span>stch.schema</span></a></li><li><a href="stch.schema.util.html"><span>stch.schema.util</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="stch.schema.html#var-%2Bmissing%2B"><span>+missing+</span></a></li><li><a href="stch.schema.html#var--%3EAnythingSchema"><span>-&gt;AnythingSchema</span></a></li><li><a href="stch.schema.html#var--%3EConditionalSchema"><span>-&gt;ConditionalSchema</span></a></li><li><a href="stch.schema.html#var--%3EEnumSchema"><span>-&gt;EnumSchema</span></a></li><li><a href="stch.schema.html#var--%3EEqSchema"><span>-&gt;EqSchema</span></a></li><li><a href="stch.schema.html#var--%3EFnSchema"><span>-&gt;FnSchema</span></a></li><li><a href="stch.schema.html#var--%3EIntersectionSchema"><span>-&gt;IntersectionSchema</span></a></li><li><a href="stch.schema.html#var--%3EMapEntrySchema"><span>-&gt;MapEntrySchema</span></a></li><li><a href="stch.schema.html#var--%3ENamedSchema"><span>-&gt;NamedSchema</span></a></li><li><a href="stch.schema.html#var--%3EOptionSchema"><span>-&gt;OptionSchema</span></a></li><li><a href="stch.schema.html#var--%3EOptionalKey"><span>-&gt;OptionalKey</span></a></li><li><a href="stch.schema.html#var--%3EPredicateSchema"><span>-&gt;PredicateSchema</span></a></li><li><a href="stch.schema.html#var--%3EProtocolSchema"><span>-&gt;ProtocolSchema</span></a></li><li><a href="stch.schema.html#var--%3ERecordSchema"><span>-&gt;RecordSchema</span></a></li><li><a href="stch.schema.html#var--%3ERecursiveSchema"><span>-&gt;RecursiveSchema</span></a></li><li><a href="stch.schema.html#var--%3ERequiredKey"><span>-&gt;RequiredKey</span></a></li><li><a href="stch.schema.html#var--%3ESingle"><span>-&gt;Single</span></a></li><li><a href="stch.schema.html#var--%3EUnionSchema"><span>-&gt;UnionSchema</span></a></li><li><a href="stch.schema.html#var-Any"><span>Any</span></a></li><li><a href="stch.schema.html#var-Atom"><span>Atom</span></a></li><li><a href="stch.schema.html#var-Date"><span>Date</span></a></li><li><a href="stch.schema.html#var-Enumerate"><span>Enumerate</span></a></li><li><a href="stch.schema.html#var-Eq"><span>Eq</span></a></li><li><a href="stch.schema.html#var-Fn"><span>Fn</span></a></li><li><a href="stch.schema.html#var-I"><span>I</span></a></li><li><a href="stch.schema.html#var-Int"><span>Int</span></a></li><li><a href="stch.schema.html#var-Keyword"><span>Keyword</span></a></li><li><a href="stch.schema.html#var-List"><span>List</span></a></li><li><a href="stch.schema.html#var-Map"><span>Map</span></a></li><li><a href="stch.schema.html#var-Named"><span>Named</span></a></li><li><a href="stch.schema.html#var-Num"><span>Num</span></a></li><li><a href="stch.schema.html#var-One"><span>One</span></a></li><li><a href="stch.schema.html#var-Option"><span>Option</span></a></li><li><a href="stch.schema.html#var-Optional"><span>Optional</span></a></li><li><a href="stch.schema.html#var-Pair"><span>Pair</span></a></li><li><a href="stch.schema.html#var-Predicate"><span>Predicate</span></a></li><li><a href="stch.schema.html#var-Protocol"><span>Protocol</span></a></li><li><a href="stch.schema.html#var-Queue"><span>Queue</span></a></li><li><a href="stch.schema.html#var-Ratio"><span>Ratio</span></a></li><li><a href="stch.schema.html#var-Record"><span>Record</span></a></li><li><a href="stch.schema.html#var-Regex"><span>Regex</span></a></li><li><a href="stch.schema.html#var-Schema"><span>Schema</span></a></li><li><a href="stch.schema.html#var-Set"><span>Set</span></a></li><li><a href="stch.schema.html#var-Symbol"><span>Symbol</span></a></li><li><a href="stch.schema.html#var-U"><span>U</span></a></li><li><a href="stch.schema.html#var-UUID"><span>UUID</span></a></li><li><a href="stch.schema.html#var-Vector"><span>Vector</span></a></li><li><a href="stch.schema.html#var-assert%21"><span>assert!</span></a></li><li><a href="stch.schema.html#var-check"><span>check</span></a></li><li><a href="stch.schema.html#var-checker"><span>checker</span></a></li><li><a href="stch.schema.html#var-conditional"><span>conditional</span></a></li><li><a href="stch.schema.html#var-defn%27"><span>defn'</span></a></li><li><a href="stch.schema.html#var-defrecord%27"><span>defrecord'</span></a></li><li><a href="stch.schema.html#var-error%21"><span>error!</span></a></li><li><a href="stch.schema.html#var-explain"><span>explain</span></a></li><li><a href="stch.schema.html#var-explicit-schema-key"><span>explicit-schema-key</span></a></li><li><a href="stch.schema.html#var-fn%27"><span>fn'</span></a></li><li><a href="stch.schema.html#var-fn-schema"><span>fn-schema</span></a></li><li><a href="stch.schema.html#var-letfn%27"><span>letfn'</span></a></li><li><a href="stch.schema.html#var-make-fn-schema"><span>make-fn-schema</span></a></li><li><a href="stch.schema.html#var-map-%3EAnythingSchema"><span>map-&gt;AnythingSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EConditionalSchema"><span>map-&gt;ConditionalSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EEnumSchema"><span>map-&gt;EnumSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EEqSchema"><span>map-&gt;EqSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EFnSchema"><span>map-&gt;FnSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EIntersectionSchema"><span>map-&gt;IntersectionSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EMapEntrySchema"><span>map-&gt;MapEntrySchema</span></a></li><li><a href="stch.schema.html#var-map-%3ENamedSchema"><span>map-&gt;NamedSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EOptionSchema"><span>map-&gt;OptionSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EOptionalKey"><span>map-&gt;OptionalKey</span></a></li><li><a href="stch.schema.html#var-map-%3EPredicateSchema"><span>map-&gt;PredicateSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EProtocolSchema"><span>map-&gt;ProtocolSchema</span></a></li><li><a href="stch.schema.html#var-map-%3ERecordSchema"><span>map-&gt;RecordSchema</span></a></li><li><a href="stch.schema.html#var-map-%3ERecursiveSchema"><span>map-&gt;RecursiveSchema</span></a></li><li><a href="stch.schema.html#var-map-%3ERequiredKey"><span>map-&gt;RequiredKey</span></a></li><li><a href="stch.schema.html#var-map-%3ESingle"><span>map-&gt;Single</span></a></li><li><a href="stch.schema.html#var-map-%3EUnionSchema"><span>map-&gt;UnionSchema</span></a></li><li><a href="stch.schema.html#var-map-entry"><span>map-entry</span></a></li><li><a href="stch.schema.html#var-named"><span>named</span></a></li><li><a href="stch.schema.html#var-optional-key"><span>optional-key</span></a></li><li><a href="stch.schema.html#var-optional-key%3F"><span>optional-key?</span></a></li><li><a href="stch.schema.html#var-pred-internal"><span>pred-internal</span></a></li><li><a href="stch.schema.html#var-protocol-name"><span>protocol-name</span></a></li><li><a href="stch.schema.html#var-recursive"><span>recursive</span></a></li><li><a href="stch.schema.html#var-required-key"><span>required-key</span></a></li><li><a href="stch.schema.html#var-required-key%3F"><span>required-key?</span></a></li><li><a href="stch.schema.html#var-safe-get"><span>safe-get</span></a></li><li><a href="stch.schema.html#var-schema-choice"><span>schema-choice</span></a></li><li><a href="stch.schema.html#var-schematize-fn"><span>schematize-fn</span></a></li><li><a href="stch.schema.html#var-set-fn-validation%21"><span>set-fn-validation!</span></a></li><li><a href="stch.schema.html#var-specific-key%3F"><span>specific-key?</span></a></li><li><a href="stch.schema.html#var-start-walker"><span>start-walker</span></a></li><li><a href="stch.schema.html#var-subschema-walker"><span>subschema-walker</span></a></li><li><a href="stch.schema.html#var-validate"><span>validate</span></a></li><li><a href="stch.schema.html#var-validation-error"><span>validation-error</span></a></li><li><a href="stch.schema.html#var-walker"><span>walker</span></a></li><li><a href="stch.schema.html#var-with-fn-validation"><span>with-fn-validation</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>stch.schema documentation</h2><pre class="doc">A library for data shape definition and validation.
A Schema is just Clojure data, which can be used to
document and validate Clojure functions and data.

For example,

(def FooBar {:foo Keyword :bar [Number]}) ;; a schema

(check FooBar {:foo :k :bar [1.0 2.0 3.0]})
==&gt; nil

representing successful validation, but the following
all return helpful errors describing how the provided
data fails to measure up to schema FooBar's standards.

(check FooBar {:bar [1.0 2.0 3.0]})
==&gt; {:foo missing-required-key}

(check FooBar {:foo 1 :bar [1.0 2.0 3.0]})
==&gt; {:foo (not (keyword? 1))}

(check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})
==&gt; {:baz disallowed-key}

Schema lets you describe your leaf values using the
Any, Keyword, Number, String, and Int definitions below,
or (in Clojure) you can use arbitrary Java classes or
primitive casts to describe simple values.

From there, you can build up schemas for complex types
using Clojure syntax (map literals for maps, set literals
for sets, vector literals for sequences, with details
described below), plus helpers below that provide optional values,
enumerations, arbitrary predicates, and more.

Schema also provides macros for defining records with
schematized elements (defrecord'), and named or anonymous
functions (fn' and defn') with schematized inputs and
return values.  In addition to producing better-documented
records and functions, these macros allow you to retrieve
the schema associated with the defined record or function.
Moreover, functions include optional *validation*, which will throw
an error if the inputs or outputs do not match the provided schemas:

(defrecord' FooBar
  [foo :- Int
   bar :- String])

(defn' quux :- Int
  [foobar :- Foobar
   mogrifier :- Number]
  (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))

(quux (FooBar. 10 &quot;5&quot;) 2)
==&gt; 30

(fn-schema quux)
==&gt; (Fn Int [(Record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number])

(with-fn-validation (quux (FooBar. 10.2 &quot;5&quot;) 2))
==&gt; Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]

As you can see, the preferred syntax for providing
type hints to schema's defrecord', fn', and defn' macros
is to follow each element, argument, or function name with a
:- schema.  Symbols without schemas default to a schema of Any.
In Clojure, class (e.g., java.lang.String) and primitive schemas
(long, double) are also propagated to tag metadata to ensure
you get the type hinting and primitive behavior you ask for.

If you don't like this style, standard Clojure-style
typehints are also supported:

(fn-schema (fn' [^String x]))
==&gt; (Fn Any [java.lang.String])

You can directly type hint a symbol as a class, primitive,
protocol, or simple schema.  For complex schemas, due to Clojure's
rules about ^, you must enclose the schema in a {:s schema}
map like so:

(fn-schema (fn' [^{:s [String]} x]))
(Fn Any [java.lang.String])

(We highly prefer the :- syntax to this abomination, however.)
See the docstrings of defrecord', fn', and defn' for more
details about how to use these macros.</pre><div class="public" id="var-%2Bmissing%2B"><h3>+missing+</h3><div class="usage"></div><pre class="doc">A sentinel value representing missing portions
of the input data.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1052">Source</a></div></div><div class="public" id="var--%3EAnythingSchema"><h3>-&gt;AnythingSchema</h3><div class="usage"><code>(-&gt;AnythingSchema _)</code></div><pre class="doc">Positional factory function for class stch.schema.AnythingSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L767">Source</a></div></div><div class="public" id="var--%3EConditionalSchema"><h3>-&gt;ConditionalSchema</h3><div class="usage"><code>(-&gt;ConditionalSchema preds-and-schemas)</code></div><pre class="doc">Positional factory function for class stch.schema.ConditionalSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L965">Source</a></div></div><div class="public" id="var--%3EEnumSchema"><h3>-&gt;EnumSchema</h3><div class="usage"><code>(-&gt;EnumSchema vs)</code></div><pre class="doc">Positional factory function for class stch.schema.EnumSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L797">Source</a></div></div><div class="public" id="var--%3EEqSchema"><h3>-&gt;EqSchema</h3><div class="usage"><code>(-&gt;EqSchema v)</code></div><pre class="doc">Positional factory function for class stch.schema.EqSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L781">Source</a></div></div><div class="public" id="var--%3EFnSchema"><h3>-&gt;FnSchema</h3><div class="usage"><code>(-&gt;FnSchema output-schema input-schemas)</code></div><pre class="doc">Positional factory function for class stch.schema.FnSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1370">Source</a></div></div><div class="public" id="var--%3EIntersectionSchema"><h3>-&gt;IntersectionSchema</h3><div class="usage"><code>(-&gt;IntersectionSchema schemas)</code></div><pre class="doc">Positional factory function for class stch.schema.IntersectionSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L941">Source</a></div></div><div class="public" id="var--%3EMapEntrySchema"><h3>-&gt;MapEntrySchema</h3><div class="usage"><code>(-&gt;MapEntrySchema kspec val-schema)</code></div><pre class="doc">Positional factory function for class stch.schema.MapEntrySchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1103">Source</a></div></div><div class="public" id="var--%3ENamedSchema"><h3>-&gt;NamedSchema</h3><div class="usage"><code>(-&gt;NamedSchema schema name)</code></div><pre class="doc">Positional factory function for class stch.schema.NamedSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L903">Source</a></div></div><div class="public" id="var--%3EOptionSchema"><h3>-&gt;OptionSchema</h3><div class="usage"><code>(-&gt;OptionSchema schema)</code></div><pre class="doc">Positional factory function for class stch.schema.OptionSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L887">Source</a></div></div><div class="public" id="var--%3EOptionalKey"><h3>-&gt;OptionalKey</h3><div class="usage"><code>(-&gt;OptionalKey k)</code></div><pre class="doc">Positional factory function for class stch.schema.OptionalKey.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1071">Source</a></div></div><div class="public" id="var--%3EPredicateSchema"><h3>-&gt;PredicateSchema</h3><div class="usage"><code>(-&gt;PredicateSchema p? pred-name)</code></div><pre class="doc">Positional factory function for class stch.schema.PredicateSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L813">Source</a></div></div><div class="public" id="var--%3EProtocolSchema"><h3>-&gt;ProtocolSchema</h3><div class="usage"><code>(-&gt;ProtocolSchema p)</code></div><pre class="doc">Positional factory function for class stch.schema.ProtocolSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L850">Source</a></div></div><div class="public" id="var--%3ERecordSchema"><h3>-&gt;RecordSchema</h3><div class="usage"><code>(-&gt;RecordSchema klass schema)</code></div><pre class="doc">Positional factory function for class stch.schema.RecordSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1325">Source</a></div></div><div class="public" id="var--%3ERecursiveSchema"><h3>-&gt;RecursiveSchema</h3><div class="usage"><code>(-&gt;RecursiveSchema schema-var)</code></div><pre class="doc">Positional factory function for class stch.schema.RecursiveSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1006">Source</a></div></div><div class="public" id="var--%3ERequiredKey"><h3>-&gt;RequiredKey</h3><div class="usage"><code>(-&gt;RequiredKey k)</code></div><pre class="doc">Positional factory function for class stch.schema.RequiredKey.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1057">Source</a></div></div><div class="public" id="var--%3ESingle"><h3>-&gt;Single</h3><div class="usage"><code>(-&gt;Single schema optional? name)</code></div><pre class="doc">Positional factory function for class stch.schema.Single.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1227">Source</a></div></div><div class="public" id="var--%3EUnionSchema"><h3>-&gt;UnionSchema</h3><div class="usage"><code>(-&gt;UnionSchema schemas)</code></div><pre class="doc">Positional factory function for class stch.schema.UnionSchema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L918">Source</a></div></div><div class="public" id="var-Any"><h3>Any</h3><div class="usage"></div><pre class="doc">Any value, including nil.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L775">Source</a></div></div><div class="public" id="var-Atom"><h3>Atom</h3><div class="usage"></div><pre class="doc">A Clojure atom
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1443">Source</a></div></div><div class="public" id="var-Date"><h3>Date</h3><div class="usage"></div><pre class="doc">A Java date.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1451">Source</a></div></div><div class="public" id="var-Enumerate"><h3>Enumerate</h3><div class="usage"><code>(Enumerate &amp; vs)</code></div><pre class="doc">A value that must be = to some element of vs.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L806">Source</a></div></div><div class="public" id="var-Eq"><h3>Eq</h3><div class="usage"><code>(Eq v)</code></div><pre class="doc">A value that must be (= v).
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L790">Source</a></div></div><div class="public" id="var-Fn"><h3>Fn</h3><h4 class="macro">macro</h4><div class="usage"><code>(Fn)</code><code>(Fn output-schema &amp; arity-schema-specs)</code></div><pre class="doc">Produce a function schema from an output schema
and a list of arity input schema specs, each of which
is a vector of argument schemas, ending with an optional
'&amp; more-schema' specification where more-schema must
be a sequence schema.

Currently function schemas are purely descriptive;
there is no validation except for functions defined directly
by fn' or defn'.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L384">Source</a></div></div><div class="public" id="var-I"><h3>I</h3><div class="usage"><code>(I &amp; schemas)</code></div><pre class="doc">A value that must satisfy every schema in schemas.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L958">Source</a></div></div><div class="public" id="var-Int"><h3>Int</h3><div class="usage"></div><pre class="doc">Any integral number.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1423">Source</a></div></div><div class="public" id="var-Keyword"><h3>Keyword</h3><div class="usage"></div><pre class="doc">A Clojure keyword.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1431">Source</a></div></div><div class="public" id="var-List"><h3>List</h3><div class="usage"><code>(List)</code><code>(List x)</code></div><pre class="doc">A Clojure list of x's.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1477">Source</a></div></div><div class="public" id="var-Map"><h3>Map</h3><div class="usage"></div><pre class="doc">A Clojure map.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1463">Source</a></div></div><div class="public" id="var-Named"><h3>Named</h3><div class="usage"></div><pre class="doc">A Java string, Clojure symbol, or Clojure keyword.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1459">Source</a></div></div><div class="public" id="var-Num"><h3>Num</h3><div class="usage"></div><pre class="doc">Any number.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1427">Source</a></div></div><div class="public" id="var-One"><h3>One</h3><div class="usage"><code>(One schema)</code><code>(One schema name)</code></div><pre class="doc">A single required element of a sequence
(not repeated, the implicit default).</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1229">Source</a></div></div><div class="public" id="var-Option"><h3>Option</h3><div class="usage"><code>(Option schema)</code></div><pre class="doc">A value that must either be nil or satisfy schema.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L896">Source</a></div></div><div class="public" id="var-Optional"><h3>Optional</h3><div class="usage"><code>(Optional schema)</code><code>(Optional schema name)</code></div><pre class="doc">A single optional element of a sequence
(not repeated, the implicit default).</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1236">Source</a></div></div><div class="public" id="var-Pair"><h3>Pair</h3><div class="usage"><code>(Pair first-schema second-schema)</code><code>(Pair first-schema first-name second-schema second-name)</code></div><pre class="doc">A schema for a pair of schemas and
optionally their names.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1308">Source</a></div></div><div class="public" id="var-Predicate"><h3>Predicate</h3><h4 class="macro">macro</h4><div class="usage"><code>(Predicate p?)</code><code>(Predicate p? pred-name)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L836">Source</a></div></div><div class="public" id="var-Protocol"><h3>Protocol</h3><div class="usage"><code>(Protocol p)</code></div><pre class="doc">A value that must satsify? protocol p.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L859">Source</a></div></div><div class="public" id="var-Queue"><h3>Queue</h3><div class="usage"><code>(Queue)</code><code>(Queue x)</code></div><pre class="doc">A Clojure queue of x's.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1483">Source</a></div></div><div class="public" id="var-Ratio"><h3>Ratio</h3><div class="usage"></div><pre class="doc">A Clojure ratio
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1439">Source</a></div></div><div class="public" id="var-Record"><h3>Record</h3><div class="usage"><code>(Record klass schema)</code></div><pre class="doc">A Record instance of type klass, whose
elements match map schema 'schema'.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1344">Source</a></div></div><div class="public" id="var-Regex"><h3>Regex</h3><div class="usage"></div><pre class="doc">A regular expression.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1447">Source</a></div></div><div class="public" id="var-Schema"><h3>Schema</h3><div class="usage"></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L625">Source</a></div></div><div class="public" id="var-Set"><h3>Set</h3><div class="usage"></div><pre class="doc">A Clojure set.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1467">Source</a></div></div><div class="public" id="var-Symbol"><h3>Symbol</h3><div class="usage"></div><pre class="doc">A Clojure symbol.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1435">Source</a></div></div><div class="public" id="var-U"><h3>U</h3><div class="usage"><code>(U &amp; schemas)</code></div><pre class="doc">A value that must satisfy at least one schema in schemas.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L934">Source</a></div></div><div class="public" id="var-UUID"><h3>UUID</h3><div class="usage"></div><pre class="doc">A Java UUID.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1455">Source</a></div></div><div class="public" id="var-Vector"><h3>Vector</h3><div class="usage"><code>(Vector)</code><code>(Vector x)</code></div><pre class="doc">A Clojure vector of x's.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1471">Source</a></div></div><div class="public" id="var-assert%21"><h3>assert!</h3><h4 class="macro">macro</h4><div class="usage"><code>(assert! form &amp; format-args)</code></div><pre class="doc">Like assert, but throws a RuntimeException and
takes args to format. Only for use in client-code.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L124">Source</a></div></div><div class="public" id="var-check"><h3>check</h3><div class="usage"><code>(check schema x)</code></div><pre class="doc">Return nil if x matches schema; otherwise, returns a
value that looks like the 'bad' parts of x with
ValidationErrors at the leaves describing the failures.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L693">Source</a></div></div><div class="public" id="var-checker"><h3>checker</h3><div class="usage"><code>(checker schema)</code></div><pre class="doc">Compile an efficient checker for schema, which returns
nil for valid values and error descriptions otherwise.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L687">Source</a></div></div><div class="public" id="var-conditional"><h3>conditional</h3><div class="usage"><code>(conditional &amp; preds-and-schemas)</code></div><pre class="doc">Define a conditional schema.  Takes args like cond,
(conditional pred1 schema1 pred2 schema2 ...),
and checks the first schema where pred is true on the value.
Unlike cond, throws if the value does not match any condition.
:else may be used as a final condition in the place of (constantly true).
More efficient than U, since only one schema must be checked.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L979">Source</a></div></div><div class="public" id="var-defn%27"><h3>defn'</h3><h4 class="macro">macro</h4><div class="usage"><code>(defn' &amp; defn-args)</code></div><pre class="doc">Like defn, except that schema-style typehints can
be given on the argument symbols and on the function
name (for the return value).

You can call fn-schema on the defined function to
get its schema back, or use with-fn-validation to
enable runtime checking of function inputs and outputs.

(defn' foo :- Num
  [x :- Int
   y :- Num]
  (* x y))

(fn-schema foo)
==&gt; (Fn java.lang.Number [Int java.lang.Number])

(with-fn-validation (foo 1 2))
==&gt; 2

(with-fn-validation (foo 1.5 2))
==&gt; Input to foo does not match schema: [(named (not (integer? 1.5)) x) nil]

See (doc stch.schema) for details of the :- syntax for
arguments and return schemas.

The overhead for checking if run-time validation should be used is very
small -- about 5% of a very small fn call.  On top of that, actual
validation costs what it costs.

You can also turn on validation unconditionally for this
fn only by putting ^:always-validate metadata on the fn name.

Gotchas and limitations:
- The output schema always goes on the fn name, not the
arg vector. This means that all arities must share the same
output schema. Schema will automatically propagate primitive
hints to the arg vector and class hints to the fn name,
so that you get the behavior you expect from Clojure.
- Schema metadata is only processed on top-level arguments.
I.e., you can use destructuring, but you must put schema
metadata on the top-level arguments, not the destructured variables.

Bad:  (defn' foo [{:keys [x :- Int]}])
Good: (defn' foo [{:keys [x]} :- {:x Int}])
- Only a specific subset of rest-arg destructuring is supported:
- &amp; rest works as expected
- &amp; [a b] works, with schemas for individual elements parsed
out of the binding, or an overall schema on the vector.
- &amp; {} is not supported.
- Unlike defn, a final attr-map on multi-arity functions
is not supported.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L529">Source</a></div></div><div class="public" id="var-defrecord%27"><h3>defrecord'</h3><h4 class="macro">macro</h4><div class="usage"><code>(defrecord' name field-schema extra-key-schema? extra-validator-fn? &amp; opts+specs)</code></div><pre class="doc">Define a record with a schema.

In addition to the ordinary behavior of defrecord,
this macro produces a schema for the Record, which
will automatically be used when validating instances of
the Record class:

(defrecord' FooBar
  [foo :- Int
   bar :- String])

(stch.schema.util/class-schema FooBar)
==&gt; (Record user.FooBar {:foo Int, :bar java.lang.String})

(check FooBar (FooBar. 1.2 :not-a-string))
==&gt; {:foo (not (integer? 1.2)), :bar (not (instance? java.lang.String :not-a-string))}

See (doc stch.schema) for details of the :- syntax
for record elements.

Moreover, optional arguments extra-key-schema? and
extra-validator-fn? can be passed to augment the record schema.
- extra-key-schema is a map schema that defines validation
for additional key-value pairs not in the record base
(the default is to not allow extra mappings).
- extra-validator-fn? is an additional predicate that
will be used as part of validating the record value.

The remaining opts+specs (i.e., protocol and interface
implementations) are passed through directly to defrecord.

Finally, this macro replaces Clojure's map-&gt;name constructor
with one that is more than an order of magnitude faster
(as of Clojure 1.5), and provides a new strict-map-&gt;name
constructor that throws or drops extra keys not in the
record base.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L402">Source</a></div></div><div class="public" id="var-error%21"><h3>error!</h3><h4 class="macro">macro</h4><div class="usage"><code>(error! s)</code><code>(error! s m)</code></div><pre class="doc">Generate a cross-platform exception in client
(non-compilation) code.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L105">Source</a></div></div><div class="public" id="var-explain"><h3>explain</h3><div class="usage"><code>(explain this)</code></div><pre class="doc">Expand this schema to a human-readable format suitable
for pprinting, also expanding class schematas at the leaves.
Example:

user&gt; (explain {:a Keyword :b [Int]} )
{:a Keyword, :b [Int]}</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/#L">Source</a></div></div><div class="public" id="var-explicit-schema-key"><h3>explicit-schema-key</h3><div class="usage"><code>(explicit-schema-key ks)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1081">Source</a></div></div><div class="public" id="var-fn%27"><h3>fn'</h3><h4 class="macro">macro</h4><div class="usage"><code>(fn' &amp; fn-args)</code></div><pre class="doc">fn' : defn' :: clojure.core/fn : defn

See (doc defn) for details.

Additional gotchas and limitations:
- Like defn', the output schema must go on the fn name.
If you want an output schema, your function must have a name.
- Unlike defn', the function schema is stored in metadata on the fn.
Clojure's implementation for metadata on fns currently produces a
wrapper fn, which will decrease performance and negate the benefits
of primitive type hints compared to clojure.core/fn.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L493">Source</a></div></div><div class="public" id="var-fn-schema"><h3>fn-schema</h3><div class="usage"><code>(fn-schema f)</code></div><pre class="doc">Produce the schema for a function defined
with fn' or defn'.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1412">Source</a></div></div><div class="public" id="var-letfn%27"><h3>letfn'</h3><h4 class="macro">macro</h4><div class="usage"><code>(letfn' fnspecs# &amp; body#)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L607">Source</a></div></div><div class="public" id="var-make-fn-schema"><h3>make-fn-schema</h3><div class="usage"><code>(make-fn-schema output-schema input-schemas)</code></div><pre class="doc">A function outputting a value in output schema,
whose argument vector must match one of input-schemas,
each of which should be a sequence schema. Currently
function schemas are purely descriptive; they validate
against any function, regargless of actual input and
output types.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1387">Source</a></div></div><div class="public" id="var-map-%3EAnythingSchema"><h3>map-&gt;AnythingSchema</h3><div class="usage"><code>(map-&gt;AnythingSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.AnythingSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L767">Source</a></div></div><div class="public" id="var-map-%3EConditionalSchema"><h3>map-&gt;ConditionalSchema</h3><div class="usage"><code>(map-&gt;ConditionalSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.ConditionalSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L965">Source</a></div></div><div class="public" id="var-map-%3EEnumSchema"><h3>map-&gt;EnumSchema</h3><div class="usage"><code>(map-&gt;EnumSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.EnumSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L797">Source</a></div></div><div class="public" id="var-map-%3EEqSchema"><h3>map-&gt;EqSchema</h3><div class="usage"><code>(map-&gt;EqSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.EqSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L781">Source</a></div></div><div class="public" id="var-map-%3EFnSchema"><h3>map-&gt;FnSchema</h3><div class="usage"><code>(map-&gt;FnSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.FnSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1370">Source</a></div></div><div class="public" id="var-map-%3EIntersectionSchema"><h3>map-&gt;IntersectionSchema</h3><div class="usage"><code>(map-&gt;IntersectionSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.IntersectionSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L941">Source</a></div></div><div class="public" id="var-map-%3EMapEntrySchema"><h3>map-&gt;MapEntrySchema</h3><div class="usage"><code>(map-&gt;MapEntrySchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.MapEntrySchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1103">Source</a></div></div><div class="public" id="var-map-%3ENamedSchema"><h3>map-&gt;NamedSchema</h3><div class="usage"><code>(map-&gt;NamedSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.NamedSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L903">Source</a></div></div><div class="public" id="var-map-%3EOptionSchema"><h3>map-&gt;OptionSchema</h3><div class="usage"><code>(map-&gt;OptionSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.OptionSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L887">Source</a></div></div><div class="public" id="var-map-%3EOptionalKey"><h3>map-&gt;OptionalKey</h3><div class="usage"><code>(map-&gt;OptionalKey m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.OptionalKey, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1071">Source</a></div></div><div class="public" id="var-map-%3EPredicateSchema"><h3>map-&gt;PredicateSchema</h3><div class="usage"><code>(map-&gt;PredicateSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.PredicateSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L813">Source</a></div></div><div class="public" id="var-map-%3EProtocolSchema"><h3>map-&gt;ProtocolSchema</h3><div class="usage"><code>(map-&gt;ProtocolSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.ProtocolSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L850">Source</a></div></div><div class="public" id="var-map-%3ERecordSchema"><h3>map-&gt;RecordSchema</h3><div class="usage"><code>(map-&gt;RecordSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.RecordSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1325">Source</a></div></div><div class="public" id="var-map-%3ERecursiveSchema"><h3>map-&gt;RecursiveSchema</h3><div class="usage"><code>(map-&gt;RecursiveSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.RecursiveSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1006">Source</a></div></div><div class="public" id="var-map-%3ERequiredKey"><h3>map-&gt;RequiredKey</h3><div class="usage"><code>(map-&gt;RequiredKey m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.RequiredKey, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1057">Source</a></div></div><div class="public" id="var-map-%3ESingle"><h3>map-&gt;Single</h3><div class="usage"><code>(map-&gt;Single m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.Single, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1227">Source</a></div></div><div class="public" id="var-map-%3EUnionSchema"><h3>map-&gt;UnionSchema</h3><div class="usage"><code>(map-&gt;UnionSchema m__5818__auto__)</code></div><pre class="doc">Factory function for class stch.schema.UnionSchema, taking a map of keywords to field values.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L918">Source</a></div></div><div class="public" id="var-map-entry"><h3>map-entry</h3><div class="usage"><code>(map-entry kspec val-schema)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1141">Source</a></div></div><div class="public" id="var-named"><h3>named</h3><div class="usage"><code>(named schema name)</code></div><pre class="doc">A value that must satisfy schema, and has a name
for documentation purposes.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L910">Source</a></div></div><div class="public" id="var-optional-key"><h3>optional-key</h3><div class="usage"><code>(optional-key k)</code></div><pre class="doc">An optional key in a map.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1073">Source</a></div></div><div class="public" id="var-optional-key%3F"><h3>optional-key?</h3><div class="usage"><code>(optional-key? ks)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1078">Source</a></div></div><div class="public" id="var-pred-internal"><h3>pred-internal</h3><div class="usage"><code>(pred-internal p? pred-name)</code></div><pre class="doc">A value for which p? returns true (and does not throw).
Optional pred-name can be passed for nicer validation errors.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L828">Source</a></div></div><div class="public" id="var-protocol-name"><h3>protocol-name</h3><div class="usage"><code>(protocol-name protocol)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L844">Source</a></div></div><div class="public" id="var-recursive"><h3>recursive</h3><div class="usage"><code>(recursive schema-var)</code></div><pre class="doc">Support for (mutually) recursive schemas by passing a var that points to a schema,
e.g (recursive #'ExampleRecursiveSchema).</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1017">Source</a></div></div><div class="public" id="var-required-key"><h3>required-key</h3><div class="usage"><code>(required-key k)</code></div><pre class="doc">A required key in a map.
</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1059">Source</a></div></div><div class="public" id="var-required-key%3F"><h3>required-key?</h3><div class="usage"><code>(required-key? ks)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1066">Source</a></div></div><div class="public" id="var-safe-get"><h3>safe-get</h3><h4 class="macro">macro</h4><div class="usage"><code>(safe-get m k)</code></div><pre class="doc">Like get but throw an exception if not found.
A macro just to work around cljx function
placement restrictions. Only valid in client
(non-compilation) code.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L113">Source</a></div></div><div class="public" id="var-schema-choice"><h3>schema-choice</h3><div class="usage"><code>(schema-choice pred if-schema else-schema)</code></div><pre class="doc">If the predicate returns truthy, use the if-schema,
otherwise use the else-schema.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L992">Source</a></div></div><div class="public" id="var-schematize-fn"><h3>schematize-fn</h3><div class="usage"><code>(schematize-fn f schema)</code></div><pre class="doc">Attach the schema to fn f at runtime,
extractable by fn-schema.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1406">Source</a></div></div><div class="public" id="var-set-fn-validation%21"><h3>set-fn-validation!</h3><div class="usage"><code>(set-fn-validation! on?)</code></div><pre class="doc">Globally turn on schema validation for all
fn' and defn' instances.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1400">Source</a></div></div><div class="public" id="var-specific-key%3F"><h3>specific-key?</h3><div class="usage"><code>(specific-key? ks)</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L1087">Source</a></div></div><div class="public" id="var-start-walker"><h3>start-walker</h3><div class="usage"><code>(start-walker sub-walker schema)</code></div><pre class="doc">The entry point for creating walkers.  Binds the provided
walker to subschema-walker, then calls it on the provided schema.
For simple validation, pass walker as sub-walker. More
sophisticated behavior (coercion, etc), can be achieved by
passing a sub-walker that wraps walker with additional behavior.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L677">Source</a></div></div><div class="public" id="var-subschema-walker"><h3>subschema-walker</h3><div class="usage"></div><pre class="doc">The function to call within 'walker' implementations to
create walkers for subschemas. Can be dynamically bound
(using start-walker below) to create different walking behaviors.

For the curious, implemented using dynamic binding rather
than making walker take a subschema-walker as an argument
because some behaviors (e.g. recursive schema walkers)
seem to require mind-bending things like fixed-point
combinators that way, but are simple this way.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L661">Source</a></div></div><div class="public" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate schema value)</code></div><pre class="doc">Throw an exception if value does not satisfy schema;
otherwise, return value.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L700">Source</a></div></div><div class="public" id="var-validation-error"><h3>validation-error</h3><h4 class="macro">macro</h4><div class="usage"><code>(validation-error schema value expectation &amp; [fail-explanation])</code></div><pre class="doc"></pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L138">Source</a></div></div><div class="public" id="var-walker"><h3>walker</h3><div class="usage"><code>(walker this)</code></div><pre class="doc">Produce a function that takes [data], and either
returns a walked version of data (by default, usually
just data), or a util/ErrorContainer containing value
that looks like the 'bad' parts of data with ValidationErrors
at the leaves describing the failures.

If this is a composite schema, should let-bind (subschema-walker
sub-schema) for each subschema outside the returned fn.
Within the returned fn, should break down data into constituents,
call the let-bound subschema walkers on each component, and then
reassemble the components into a walked version of the data
(or an ErrorContainer describing the validaiton failures).

Attempting to walk a value that already contains a
util/ErrorContainer produces undefined behavior.

User code should never call `walker` directly.
Instead, it should call `start-walker` below.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/#L">Source</a></div></div><div class="public" id="var-with-fn-validation"><h3>with-fn-validation</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-fn-validation &amp; body)</code></div><pre class="doc">Execute body with input and ouptut schema validation
turned on for all defn' and fn' instances.</pre><div class="src-link"><a href="https://github.com/stch-library/schema/blob/master/src/stch/schema.clj#L614">Source</a></div></div></div></body></html>