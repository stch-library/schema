<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>Schema 0.3.3 API documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Schema 0.3.3 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="stch.schema.html"><span>stch.schema</span></a></li><li><a href="stch.schema.util.html"><span>stch.schema.util</span></a></li></ul></div><div class="namespace-index" id="content"><h2>Schema 0.3.3 API documentation</h2><div class="doc">Alternative Schema implementation.
  Clojure only at the moment.</div><div class="namespace"><h3><a href="stch.schema.html"><span>stch.schema</span></a></h3><pre class="doc">A library for data shape definition and validation.
A Schema is just Clojure data, which can be used to
document and validate Clojure functions and data.

For example,

(def FooBar {:foo Keyword :bar [Number]}) ;; a schema

(check FooBar {:foo :k :bar [1.0 2.0 3.0]})
==&gt; nil

representing successful validation, but the following
all return helpful errors describing how the provided
data fails to measure up to schema FooBar's standards.

(check FooBar {:bar [1.0 2.0 3.0]})
==&gt; {:foo missing-required-key}

(check FooBar {:foo 1 :bar [1.0 2.0 3.0]})
==&gt; {:foo (not (keyword? 1))}

(check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})
==&gt; {:baz disallowed-key}

Schema lets you describe your leaf values using the
Any, Keyword, Number, String, and Int definitions below,
or (in Clojure) you can use arbitrary Java classes or
primitive casts to describe simple values.

From there, you can build up schemas for complex types
using Clojure syntax (map literals for maps, set literals
for sets, vector literals for sequences, with details
described below), plus helpers below that provide optional values,
enumerations, arbitrary predicates, and more.

Schema also provides macros for defining records with
schematized elements (defrecord'), and named or anonymous
functions (fn' and defn') with schematized inputs and
return values.  In addition to producing better-documented
records and functions, these macros allow you to retrieve
the schema associated with the defined record or function.
Moreover, functions include optional *validation*, which will throw
an error if the inputs or outputs do not match the provided schemas:

(defrecord' FooBar
  [foo :- Int
   bar :- String])

(defn' quux :- Int
  [foobar :- Foobar
   mogrifier :- Number]
  (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))

(quux (FooBar. 10 &quot;5&quot;) 2)
==&gt; 30

(fn-schema quux)
==&gt; (Fn Int [(Record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number])

(with-fn-validation (quux (FooBar. 10.2 &quot;5&quot;) 2))
==&gt; Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]

As you can see, the preferred syntax for providing
type hints to schema's defrecord', fn', and defn' macros
is to follow each element, argument, or function name with a
:- schema.  Symbols without schemas default to a schema of Any.
In Clojure, class (e.g., java.lang.String) and primitive schemas
(long, double) are also propagated to tag metadata to ensure
you get the type hinting and primitive behavior you ask for.

If you don't like this style, standard Clojure-style
typehints are also supported:

(fn-schema (fn' [^String x]))
==&gt; (Fn Any [java.lang.String])

You can directly type hint a symbol as a class, primitive,
protocol, or simple schema.  For complex schemas, due to Clojure's
rules about ^, you must enclose the schema in a {:s schema}
map like so:

(fn-schema (fn' [^{:s [String]} x]))
(Fn Any [java.lang.String])

(We highly prefer the :- syntax to this abomination, however.)
See the docstrings of defrecord', fn', and defn' for more
details about how to use these macros.</pre><div class="index"><p>Public variables and functions:</p><ul><li><a href="stch.schema.html#var-%2Bmissing%2B"><span>+missing+</span></a></li><li><a href="stch.schema.html#var--%3EAnythingSchema"><span>-&gt;AnythingSchema</span></a></li><li><a href="stch.schema.html#var--%3EConditionalSchema"><span>-&gt;ConditionalSchema</span></a></li><li><a href="stch.schema.html#var--%3EEnumSchema"><span>-&gt;EnumSchema</span></a></li><li><a href="stch.schema.html#var--%3EEqSchema"><span>-&gt;EqSchema</span></a></li><li><a href="stch.schema.html#var--%3EFnSchema"><span>-&gt;FnSchema</span></a></li><li><a href="stch.schema.html#var--%3EIntersectionSchema"><span>-&gt;IntersectionSchema</span></a></li><li><a href="stch.schema.html#var--%3EMapEntrySchema"><span>-&gt;MapEntrySchema</span></a></li><li><a href="stch.schema.html#var--%3ENamedSchema"><span>-&gt;NamedSchema</span></a></li><li><a href="stch.schema.html#var--%3EOptionSchema"><span>-&gt;OptionSchema</span></a></li><li><a href="stch.schema.html#var--%3EOptionalKey"><span>-&gt;OptionalKey</span></a></li><li><a href="stch.schema.html#var--%3EPredicateSchema"><span>-&gt;PredicateSchema</span></a></li><li><a href="stch.schema.html#var--%3EProtocolSchema"><span>-&gt;ProtocolSchema</span></a></li><li><a href="stch.schema.html#var--%3ERecordSchema"><span>-&gt;RecordSchema</span></a></li><li><a href="stch.schema.html#var--%3ERecursiveSchema"><span>-&gt;RecursiveSchema</span></a></li><li><a href="stch.schema.html#var--%3ERequiredKey"><span>-&gt;RequiredKey</span></a></li><li><a href="stch.schema.html#var--%3ESingle"><span>-&gt;Single</span></a></li><li><a href="stch.schema.html#var--%3EUnionSchema"><span>-&gt;UnionSchema</span></a></li><li><a href="stch.schema.html#var-Any"><span>Any</span></a></li><li><a href="stch.schema.html#var-Atom"><span>Atom</span></a></li><li><a href="stch.schema.html#var-Date"><span>Date</span></a></li><li><a href="stch.schema.html#var-Enumerate"><span>Enumerate</span></a></li><li><a href="stch.schema.html#var-Eq"><span>Eq</span></a></li><li><a href="stch.schema.html#var-Fn"><span>Fn</span></a></li><li><a href="stch.schema.html#var-I"><span>I</span></a></li><li><a href="stch.schema.html#var-Int"><span>Int</span></a></li><li><a href="stch.schema.html#var-Keyword"><span>Keyword</span></a></li><li><a href="stch.schema.html#var-List"><span>List</span></a></li><li><a href="stch.schema.html#var-Map"><span>Map</span></a></li><li><a href="stch.schema.html#var-Named"><span>Named</span></a></li><li><a href="stch.schema.html#var-Num"><span>Num</span></a></li><li><a href="stch.schema.html#var-One"><span>One</span></a></li><li><a href="stch.schema.html#var-Option"><span>Option</span></a></li><li><a href="stch.schema.html#var-Optional"><span>Optional</span></a></li><li><a href="stch.schema.html#var-Pair"><span>Pair</span></a></li><li><a href="stch.schema.html#var-Predicate"><span>Predicate</span></a></li><li><a href="stch.schema.html#var-Protocol"><span>Protocol</span></a></li><li><a href="stch.schema.html#var-Queue"><span>Queue</span></a></li><li><a href="stch.schema.html#var-Ratio"><span>Ratio</span></a></li><li><a href="stch.schema.html#var-Record"><span>Record</span></a></li><li><a href="stch.schema.html#var-Regex"><span>Regex</span></a></li><li><a href="stch.schema.html#var-Schema"><span>Schema</span></a></li><li><a href="stch.schema.html#var-Set"><span>Set</span></a></li><li><a href="stch.schema.html#var-Symbol"><span>Symbol</span></a></li><li><a href="stch.schema.html#var-U"><span>U</span></a></li><li><a href="stch.schema.html#var-UUID"><span>UUID</span></a></li><li><a href="stch.schema.html#var-Vector"><span>Vector</span></a></li><li><a href="stch.schema.html#var-assert%21"><span>assert!</span></a></li><li><a href="stch.schema.html#var-check"><span>check</span></a></li><li><a href="stch.schema.html#var-checker"><span>checker</span></a></li><li><a href="stch.schema.html#var-conditional"><span>conditional</span></a></li><li><a href="stch.schema.html#var-defn%27"><span>defn'</span></a></li><li><a href="stch.schema.html#var-defrecord%27"><span>defrecord'</span></a></li><li><a href="stch.schema.html#var-error%21"><span>error!</span></a></li><li><a href="stch.schema.html#var-explain"><span>explain</span></a></li><li><a href="stch.schema.html#var-explicit-schema-key"><span>explicit-schema-key</span></a></li><li><a href="stch.schema.html#var-fn%27"><span>fn'</span></a></li><li><a href="stch.schema.html#var-fn-schema"><span>fn-schema</span></a></li><li><a href="stch.schema.html#var-letfn%27"><span>letfn'</span></a></li><li><a href="stch.schema.html#var-make-fn-schema"><span>make-fn-schema</span></a></li><li><a href="stch.schema.html#var-map-%3EAnythingSchema"><span>map-&gt;AnythingSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EConditionalSchema"><span>map-&gt;ConditionalSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EEnumSchema"><span>map-&gt;EnumSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EEqSchema"><span>map-&gt;EqSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EFnSchema"><span>map-&gt;FnSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EIntersectionSchema"><span>map-&gt;IntersectionSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EMapEntrySchema"><span>map-&gt;MapEntrySchema</span></a></li><li><a href="stch.schema.html#var-map-%3ENamedSchema"><span>map-&gt;NamedSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EOptionSchema"><span>map-&gt;OptionSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EOptionalKey"><span>map-&gt;OptionalKey</span></a></li><li><a href="stch.schema.html#var-map-%3EPredicateSchema"><span>map-&gt;PredicateSchema</span></a></li><li><a href="stch.schema.html#var-map-%3EProtocolSchema"><span>map-&gt;ProtocolSchema</span></a></li><li><a href="stch.schema.html#var-map-%3ERecordSchema"><span>map-&gt;RecordSchema</span></a></li><li><a href="stch.schema.html#var-map-%3ERecursiveSchema"><span>map-&gt;RecursiveSchema</span></a></li><li><a href="stch.schema.html#var-map-%3ERequiredKey"><span>map-&gt;RequiredKey</span></a></li><li><a href="stch.schema.html#var-map-%3ESingle"><span>map-&gt;Single</span></a></li><li><a href="stch.schema.html#var-map-%3EUnionSchema"><span>map-&gt;UnionSchema</span></a></li><li><a href="stch.schema.html#var-map-entry"><span>map-entry</span></a></li><li><a href="stch.schema.html#var-named"><span>named</span></a></li><li><a href="stch.schema.html#var-optional-key"><span>optional-key</span></a></li><li><a href="stch.schema.html#var-optional-key%3F"><span>optional-key?</span></a></li><li><a href="stch.schema.html#var-pred-internal"><span>pred-internal</span></a></li><li><a href="stch.schema.html#var-protocol-name"><span>protocol-name</span></a></li><li><a href="stch.schema.html#var-recursive"><span>recursive</span></a></li><li><a href="stch.schema.html#var-required-key"><span>required-key</span></a></li><li><a href="stch.schema.html#var-required-key%3F"><span>required-key?</span></a></li><li><a href="stch.schema.html#var-safe-get"><span>safe-get</span></a></li><li><a href="stch.schema.html#var-schema-choice"><span>schema-choice</span></a></li><li><a href="stch.schema.html#var-schematize-fn"><span>schematize-fn</span></a></li><li><a href="stch.schema.html#var-set-fn-validation%21"><span>set-fn-validation!</span></a></li><li><a href="stch.schema.html#var-specific-key%3F"><span>specific-key?</span></a></li><li><a href="stch.schema.html#var-start-walker"><span>start-walker</span></a></li><li><a href="stch.schema.html#var-subschema-walker"><span>subschema-walker</span></a></li><li><a href="stch.schema.html#var-validate"><span>validate</span></a></li><li><a href="stch.schema.html#var-validation-error"><span>validation-error</span></a></li><li><a href="stch.schema.html#var-walker"><span>walker</span></a></li><li><a href="stch.schema.html#var-with-fn-validation"><span>with-fn-validation</span></a></li></ul></div></div><div class="namespace"><h3><a href="stch.schema.util.html"><span>stch.schema.util</span></a></h3><pre class="doc">Private utilities used in schema implementation.
</pre><div class="index"><p>Public variables and functions:</p><ul><li><a href="stch.schema.util.html#var--%3EErrorContainer"><span>-&gt;ErrorContainer</span></a></li><li><a href="stch.schema.util.html#var--%3ENamedError"><span>-&gt;NamedError</span></a></li><li><a href="stch.schema.util.html#var--%3ESimpleVCell"><span>-&gt;SimpleVCell</span></a></li><li><a href="stch.schema.util.html#var--%3EValidationError"><span>-&gt;ValidationError</span></a></li><li><a href="stch.schema.util.html#var-assoc-when"><span>assoc-when</span></a></li><li><a href="stch.schema.util.html#var-class-schema"><span>class-schema</span></a></li><li><a href="stch.schema.util.html#var-declare-class-schema%21"><span>declare-class-schema!</span></a></li><li><a href="stch.schema.util.html#var-error"><span>error</span></a></li><li><a href="stch.schema.util.html#var-error-val"><span>error-val</span></a></li><li><a href="stch.schema.util.html#var-error%3F"><span>error?</span></a></li><li><a href="stch.schema.util.html#var-map-%3EErrorContainer"><span>map-&gt;ErrorContainer</span></a></li><li><a href="stch.schema.util.html#var-named-error-explain"><span>named-error-explain</span></a></li><li><a href="stch.schema.util.html#var-result-builder"><span>result-builder</span></a></li><li><a href="stch.schema.util.html#var-type-of"><span>type-of</span></a></li><li><a href="stch.schema.util.html#var-use-fn-validation"><span>use-fn-validation</span></a></li><li><a href="stch.schema.util.html#var-validation-error-explain"><span>validation-error-explain</span></a></li><li><a href="stch.schema.util.html#var-value-name"><span>value-name</span></a></li><li><a href="stch.schema.util.html#var-wrap-error-name"><span>wrap-error-name</span></a></li></ul></div></div></div></body></html>